<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arbor Classroom: Ace Logic</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        :root { --bg-color: #1a1a1a; --term-green: #4ade80; }
        body { background-color: var(--bg-color); margin: 0; overflow: hidden; font-family: 'VT323', monospace; user-select: none; }
        
        /* CRT EFFECT - Z-Index lowered to 5 (Above canvas, below UI) */
        .crt-overlay {
            position: fixed; inset: 0; pointer-events: none; z-index: 5;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker { 0% { opacity: 0.97; } 100% { opacity: 1; } }

        /* UI CONTAINERS */
        #game-wrapper { position: relative; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; background: #000; }
        canvas { image-rendering: pixelated; box-shadow: 0 0 50px rgba(0,0,0,0.8); z-index: 1; }

        /* DIALOGUE SYSTEM - Make clickable for mobile */
        .dialogue-box {
            position: absolute; bottom: 5%; width: 90%; max-width: 800px; min-height: 160px;
            background: #fff; border: 4px solid #000; box-shadow: 8px 8px 0 #000;
            padding: 25px; z-index: 20; display: none; color: #000; font-size: 1.8rem; line-height: 1.2;
            cursor: pointer; /* Indication that it is clickable */
        }
        .speaker-name {
            position: absolute; top: -25px; left: 0; background: #000; color: #fff;
            padding: 5px 15px; font-family: 'Press Start 2P', cursive; font-size: 0.8rem; border: 4px solid #000;
        }
        .next-arrow { position: absolute; bottom: 10px; right: 20px; animation: bounce 1s infinite; font-size: 1.5rem; color: #000; }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }

        /* JUDGE OVERLAY (Buttons) */
        #input-overlay {
            position: absolute; bottom: 240px; width: 100%; z-index: 30;
            display: none; flex-direction: row; align-items: center; justify-content: center; gap: 20px;
        }
        
        /* TEXT INPUT OVERLAY (Player Answer) */
        #text-overlay {
            position: absolute; bottom: 240px; width: 90%; max-width: 600px; z-index: 30;
            display: none; flex-direction: row; align-items: center; justify-content: center; gap: 10px;
        }

        #player-input {
            flex: 1; background: #000; color: #4ade80; border: 4px solid #fff;
            font-family: 'VT323', monospace; font-size: 2rem; padding: 0.5rem 1rem;
            text-transform: uppercase; outline: none; box-shadow: 6px 6px 0 rgba(0,0,0,0.5);
        }
        #btn-submit {
            background: #4ade80; color: #000; border: 4px solid #fff;
            font-family: 'Press Start 2P'; font-size: 1rem; padding: 1rem;
            cursor: pointer; box-shadow: 6px 6px 0 rgba(0,0,0,0.5);
        }
        #btn-submit:active { transform: translate(4px, 4px); box-shadow: none; }
        
        .judge-btn {
            font-family: 'Press Start 2P'; font-size: 1rem; padding: 1.5rem 2rem;
            border: 4px solid #fff; box-shadow: 6px 6px 0 rgba(0,0,0,0.5);
            cursor: pointer; transition: transform 0.1s; text-transform: uppercase;
        }
        .judge-btn:active { transform: translate(4px, 4px); box-shadow: none; }
        
        .btn-correct { background: #16a34a; color: white; }
        .btn-wrong { background: #dc2626; color: white; }
        
        /* DRAMATIC TEXT */
        .shout-bubble {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%) rotate(-5deg);
            background: #fff; color: #b91c1c; font-family: 'Press Start 2P'; font-size: 3rem;
            padding: 2rem; border: 8px solid #000; box-shadow: 15px 15px 0 rgba(0,0,0,0.5);
            z-index: 40; display: none; text-transform: uppercase;
        }
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate(-51%, -51%) rotate(-5deg); } 20%, 80% { transform: translate(-49%, -49%) rotate(-5deg); } 30%, 50%, 70% { transform: translate(-52%, -50%) rotate(-5deg); } 40%, 60% { transform: translate(-48%, -50%) rotate(-5deg); } }

        /* START MENU */
        #start-screen { position: absolute; inset: 0; background: #111; z-index: 60; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; }
        .logo-text { font-family: 'Press Start 2P'; color: #4ade80; text-shadow: 4px 4px 0 #166534; margin-bottom: 2rem; text-align: center; line-height: 1.5; }

        /* MOBILE RESPONSIVE OVERRIDES */
        @media (max-width: 768px) {
            .dialogue-box { font-size: 1.3rem; height: auto; bottom: 10px; padding: 15px; }
            .judge-btn { font-size: 0.8rem; padding: 1rem; }
            #input-overlay { bottom: 180px; }
            #text-overlay { bottom: 180px; flex-direction: column; }
            #player-input { width: 100%; }
            #btn-submit { width: 100%; }
        }
    </style>
</head>
<body>

    <div class="crt-overlay"></div>

    <div id="game-wrapper">
        <canvas id="game-canvas"></canvas>

        <!-- UI: Dialogue -->
        <div id="dialogue-box" class="dialogue-box">
            <div id="speaker-name" class="speaker-name">???</div>
            <div id="dialogue-text"></div>
            <div class="next-arrow">▼</div>
        </div>

        <!-- UI: Dramatic Shout -->
        <div id="shout-bubble" class="shout-bubble">OBJECTION!</div>

        <!-- UI: Judge Buttons (For Lolo/Timmy) -->
        <div id="input-overlay">
            <button id="btn-judge-true" class="judge-btn btn-correct">✅ CORRECT</button>
            <button id="btn-judge-false" class="judge-btn btn-wrong">❌ WRONG</button>
        </div>

        <!-- UI: Text Input (For Player) -->
        <div id="text-overlay">
            <input type="text" id="player-input" placeholder="TYPE ANSWER..." maxlength="20" autocomplete="off">
            <button id="btn-submit">SUBMIT</button>
        </div>

        <!-- UI: Start Screen -->
        <div id="start-screen">
            <h1 class="logo-text text-4xl md:text-6xl">CLASSROOM<br><span class="text-white text-2xl md:text-4xl">SIMULATOR</span></h1>
            <p class="text-gray-400 mb-8 font-mono text-center text-sm md:text-base">Evalúa a tus compañeros.<br>Escribe tus respuestas.<br>Gana el ranking.</p>
            <button id="btn-start" class="px-8 py-4 bg-green-600 hover:bg-green-500 text-white font-bold font-mono text-xl md:text-2xl border-4 border-white shadow-[6px_6px_0px_#000] active:translate-y-1 active:shadow-none transition-all">
                EMPEZAR CLASE
            </button>
        </div>
    </div>

    <!-- SCRIPTS -->
    <script type="module">
        /**
         * ASSETS.JS (Inlined)
         * Procedural Pixel Art Generator
         */
        const Colors = {
            bg: '#cccccc', // Lighter grey wall
            board: '#2b382e',
            boardFrame: '#5c4033',
            skin: '#fca',
            hair_prof: '#444',
            suit_prof: '#1f2937',
            // Student Colors matching Mock
            lola: '#ef4444',   // Red
            timmy: '#3b82f6',  // Blue
            player: '#22c55e'  // Green
        };

        class SpriteGen {
            static createCanvas(w, h) {
                const c = document.createElement('canvas');
                c.width = w; c.height = h;
                return { c, ctx: c.getContext('2d') };
            }

            static generateProfessor() {
                const { c, ctx } = this.createCanvas(64, 64);
                
                // Body
                ctx.fillStyle = Colors.suit_prof;
                ctx.fillRect(16, 32, 32, 32); 
                
                // Head
                ctx.fillStyle = Colors.skin;
                ctx.fillRect(20, 10, 24, 24);
                
                // Hair
                ctx.fillStyle = Colors.hair_prof;
                ctx.fillRect(18, 6, 28, 10);
                ctx.fillRect(18, 6, 6, 18);
                
                // Glasses
                ctx.fillStyle = '#000';
                ctx.fillRect(22, 20, 8, 4);
                ctx.fillRect(34, 20, 8, 4);
                ctx.fillStyle = '#fff';
                ctx.fillRect(23, 21, 2, 2);
                
                return c;
            }

            static generateStudent(colorOverride) {
                const { c, ctx } = this.createCanvas(64, 64);
                
                // Shirt
                ctx.fillStyle = colorOverride;
                ctx.fillRect(14, 34, 36, 30);
                
                // Head (Cube style)
                ctx.fillStyle = Colors.skin;
                ctx.fillRect(20, 14, 24, 20);
                
                // Eyes (Simple dots)
                ctx.fillStyle = '#000';
                ctx.fillRect(26, 20, 4, 4);
                ctx.fillRect(36, 20, 4, 4);
                
                return c;
            }

            static generateBackground(w, h) {
                const { c, ctx } = this.createCanvas(w, h);
                
                // Wall
                ctx.fillStyle = Colors.bg;
                ctx.fillRect(0, 0, w, h);
                
                // Floor
                ctx.fillStyle = '#4a3b32'; // Darker floor
                ctx.fillRect(0, h * 0.65, w, h * 0.35);
                
                // Blackboard (Wider)
                ctx.fillStyle = Colors.boardFrame;
                ctx.fillRect(w * 0.2 - 10, h * 0.1 - 10, w * 0.6 + 20, h * 0.35 + 20);
                ctx.fillStyle = Colors.board;
                ctx.fillRect(w * 0.2, h * 0.1, w * 0.6, h * 0.35);

                return c;
            }

            static generateDesk() {
                const { c, ctx } = this.createCanvas(80, 60);
                
                // Body (Solid wood)
                ctx.fillStyle = '#78350f';
                ctx.fillRect(0, 10, 80, 50);
                
                // Desktop Surface
                ctx.fillStyle = '#92400e'; 
                ctx.fillRect(0, 0, 80, 15);
                
                // Shadow/Detail underneath rim
                ctx.fillStyle = '#000';
                ctx.globalAlpha = 0.2;
                ctx.fillRect(5, 15, 70, 2);
                
                return c;
            }
        }
        
        /**
         * ENGINE.JS (Inlined)
         * The core logic for Arbor Classroom.
         */
        class GameEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = 800;
                this.height = 600;
                this.canvas.width = this.width;
                this.canvas.height = this.height;

                this.state = 'INIT'; 
                this.frame = 0;
                
                this.assets = {
                    prof: SpriteGen.generateProfessor(),
                    bg: SpriteGen.generateBackground(this.width, this.height),
                    desk: SpriteGen.generateDesk(),
                    studentLola: SpriteGen.generateStudent(Colors.lola),
                    studentTimmy: SpriteGen.generateStudent(Colors.timmy),
                    studentPlayer: SpriteGen.generateStudent(Colors.player)
                };
                
                let playerName = 'You';
                if (window.Arbor && window.Arbor.user) {
                    playerName = window.Arbor.user.username || 'You';
                }

                this.students = [
                    { id: 'lola', name: 'Lola', color: Colors.lola, score: 0, x: 200, y: 380, sprite: this.assets.studentLola },
                    { id: 'timmy', name: 'Timmy', color: Colors.timmy, score: 0, x: 400, y: 380, sprite: this.assets.studentTimmy },
                    { id: 'you', name: playerName, color: Colors.player, score: 0, x: 600, y: 380, sprite: this.assets.studentPlayer }
                ];

                // NEW: Load persistent score for the player
                if (window.Arbor && window.Arbor.storage) {
                    const savedScore = window.Arbor.storage.load('career_score');
                    if (savedScore) {
                        this.students[2].score = savedScore;
                    }
                }

                this.professor = { x: 700, y: 350, sprite: this.assets.prof };
                this.particles = [];
                
                this.lessonData = { text: "Loading...", concepts: [] };
                this.currentRound = 0;
                this.currentQ = null;
                this.answeringStudentIndex = 0;
                this.lastJudgmentCorrect = null;

                this.ui = {
                    dialogueBox: document.getElementById('dialogue-box'),
                    speakerName: document.getElementById('speaker-name'),
                    dialogueText: document.getElementById('dialogue-text'),
                    shoutBubble: document.getElementById('shout-bubble'),
                    overlay: document.getElementById('input-overlay'),
                    btnTrue: document.getElementById('btn-judge-true'),
                    btnFalse: document.getElementById('btn-judge-false'),
                    textOverlay: document.getElementById('text-overlay'),
                    inputField: document.getElementById('player-input'),
                    btnSubmit: document.getElementById('btn-submit')
                };

                this.inputResolver = null;
                this.textResolver = null;
                this.setupInput();
            }

            setupInput() {
                document.addEventListener('keydown', (e) => {
                    if (e.key === ' ' && this.state === 'DIALOGUE') this.advanceDialogue();
                    if (e.key === 'Enter') {
                        if (this.state === 'DIALOGUE') this.advanceDialogue();
                        if (this.state === 'INPUT_TEXT') this.submitText();
                    }
                });

                this.ui.dialogueBox.addEventListener('click', () => {
                     if (this.state === 'DIALOGUE') this.advanceDialogue();
                });

                this.ui.btnTrue.addEventListener('click', () => this.resolveInput(true));
                this.ui.btnFalse.addEventListener('click', () => this.resolveInput(false));
                this.ui.btnSubmit.addEventListener('click', () => this.submitText());
            }

            resolveInput(val) {
                if (this.state === 'INPUT' && this.inputResolver) {
                    this.inputResolver(val);
                    this.ui.overlay.style.display = 'none';
                }
            }

            submitText() {
                if (this.state === 'INPUT_TEXT' && this.textResolver) {
                    const val = this.ui.inputField.value.trim();
                    if (val.length === 0) return;
                    this.textResolver(val);
                    this.ui.textOverlay.style.display = 'none';
                    this.ui.inputField.value = '';
                    this.ui.inputField.blur();
                }
            }

            start() {
                this.loop();
                this.loadContent();
            }

            loop() {
                this.update();
                this.draw();
                this.frame++;
                requestAnimationFrame(() => this.loop());
            }

            update() {
                const bob = Math.sin(this.frame / 15) * 2;
                this.professor.yDraw = this.professor.y + bob;

                this.students.forEach((s, i) => {
                    if ((this.state === 'DIALOGUE_STUDENT' && this.answeringStudentIndex === i) || (this.state === 'PLAYER_TURN' && i === 2)) {
                        s.yDraw = s.y + Math.sin(this.frame / 5) * 5;
                    } else {
                        s.yDraw = s.y + Math.sin((this.frame + i*100) / 30);
                    }
                });

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life--;
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
            }

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);
                ctx.drawImage(this.assets.bg, 0, 0);
                this.drawBoardContent(ctx);
                this.drawRank(ctx);

                ctx.save();
                ctx.translate(this.professor.x, this.professor.yDraw);
                ctx.scale(2, 2);
                ctx.drawImage(this.assets.prof, -32, -64);
                ctx.restore();

                this.students.forEach(s => {
                    ctx.save();
                    ctx.translate(s.x, s.yDraw);
                    const isActing = (this.state === 'DIALOGUE_STUDENT' && this.students.indexOf(s) === this.answeringStudentIndex) || 
                                     (this.state === 'PLAYER_TURN' && s.id === 'you');
                    if (isActing) {
                         ctx.filter = "brightness(1.2)";
                         this.drawArrow(ctx, 0, -80);
                    }
                    ctx.scale(2, 2);
                    ctx.drawImage(s.sprite, -32, -40);
                    ctx.restore();
                    ctx.drawImage(this.assets.desk, s.x - 60, s.y - 10, 120, 90);
                });

                this.particles.forEach(p => {
                    ctx.fillStyle = p.color || '#fff';
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                });
            }

            drawBoardContent(ctx) {
                ctx.fillStyle = Colors.term_green;
                ctx.font = '20px VT323';
                ctx.textAlign = 'left';
                ctx.fillText("CLASS TOPICS:", 180, 85);
                if (!this.lessonData.concepts) return;
                let y = 120;
                this.lessonData.concepts.forEach((c, i) => {
                    ctx.fillStyle = (i === this.currentRound) ? '#fbbf24' : '#fff';
                    ctx.fillText(`- ${c.topic}`, 180, y);
                    if (c.status === 'correct') {
                        ctx.fillStyle = '#4ade80';
                        ctx.fillText("✔", 500, y);
                    } else if (c.status === 'wrong') {
                        ctx.fillStyle = '#ef4444';
                        ctx.fillText("✘", 500, y);
                    }
                    y += 35;
                });
            }

            drawRank(ctx) {
                const x = 20, y = 20, w = 140, h = 120;
                ctx.fillStyle = '#111';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.fillRect(x, y, w, h);
                ctx.strokeRect(x, y, w, h);
                ctx.fillStyle = '#fbbf24';
                ctx.font = '16px VT323';
                ctx.textAlign = 'left';
                ctx.fillText("CLASS RANK", x + 10, y + 25);
                ctx.beginPath(); ctx.moveTo(x, y+35); ctx.lineTo(x+w, y+35); ctx.stroke();
                let rowY = y + 55;
                [...this.students].sort((a,b) => b.score - a.score).forEach(s => {
                    ctx.fillStyle = s.color;
                    ctx.fillText(s.name, x + 10, rowY);
                    ctx.fillStyle = '#fff';
                    ctx.fillText(s.score + " ★", x + 100, rowY);
                    rowY += 25;
                });
            }

            drawArrow(ctx, x, y) {
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.moveTo(x - 10, y);
                ctx.lineTo(x + 10, y);
                ctx.lineTo(x, y + 10);
                ctx.fill();
            }

            clearBoard() {
                this.lessonData = { text: "...", concepts: [] };
                this.currentRound = 0;
                this.ui.dialogueBox.style.display = 'none';
                this.ui.overlay.style.display = 'none';
                this.ui.textOverlay.style.display = 'none';
            }

            // NEW: Helper to centralize player score updates and persistence
            addPlayerScore(amount) {
                const player = this.students[2];
                player.score += amount;
            
                if (window.Arbor.game) {
                    window.Arbor.game.addXP(amount);
                }
                if (window.Arbor.storage) {
                    window.Arbor.storage.save('career_score', player.score);
                }
            }

            async loadContent() {
                this.clearBoard();
                this.state = 'GENERATING';
                await this.showDialogue("SYSTEM", "Loading New Curriculum from Arbor Bridge...", false);

                let rawText = null;
                if (window.Arbor && window.Arbor.content) {
                    try {
                        const lesson = await window.Arbor.content.getNext();
                        if (lesson && lesson.text) rawText = lesson.text;
                    } catch(e) { console.warn("Arbor offline.", e); }
                }
                
                if (!rawText) {
                     await this.showDialogue("SYSTEM", "CRITICAL ERROR: NO CONTENT FROM BRIDGE.", true);
                     return;
                }

                await this.showDialogue("PROFESSOR", "Alright class, new topic!", true);
                
                const prompt = `
                Context: "${rawText.substring(0, 800)}".
                Generate 3 distinct topics. For each topic, create a short question, a CORRECT answer (max 3 words), and a PLAUSIBLE WRONG answer (max 3 words).
                Return ONLY valid JSON array:
                [
                    { "topic": "Short Topic Name", "q": "Question text", "correct": "Correct Answer", "wrong": "Wrong Answer" }
                ]
                `;

                try {
                    if (!window.Arbor || !window.Arbor.ai) throw new Error("AI Bridge not found");
                    const aiRes = await window.Arbor.ai.chat([{role: "user", content: prompt}]);
                    const json = this.parseJSON(aiRes);

                    if (json && Array.isArray(json)) {
                        this.lessonData.concepts = json.map(j => ({ ...j, status: 'pending' }));
                        await this.runRound();
                    } else {
                        throw new Error("Invalid AI format");
                    }

                } catch(e) {
                    console.error("AI Error: " + e.message);
                    await this.showDialogue("SYSTEM", "SYSTEM FAILURE. AI IS UNRESPONSIVE.", true);
                }
            }

            async runRound() {
                if (this.currentRound >= this.lessonData.concepts.length) {
                    this.victory();
                    return;
                }

                const concept = this.lessonData.concepts[this.currentRound];
                this.currentQ = concept;
                this.answeringStudentIndex = Math.floor(Math.random() * 3);
                const student = this.students[this.answeringStudentIndex];

                if (this.answeringStudentIndex === 2) { // Player's turn
                    this.state = 'PLAYER_TURN';
                    await this.showDialogue("PROFESSOR", `You! ${concept.q} Answer me.`);
                    this.state = 'INPUT_TEXT';
                    const playerText = await this.waitForText(); 
                    const cleanPlayer = playerText.toLowerCase();
                    const cleanCorrect = concept.correct.toLowerCase();
                    const isCorrect = cleanPlayer.includes(cleanCorrect) || cleanCorrect.includes(cleanPlayer);

                    if (isCorrect) {
                        this.shout("CORRECT!");
                        this.spawnParticles(student.x, student.y, '#4ade80');
                        this.addPlayerScore(20);
                        concept.status = 'correct';
                        await this.showDialogue("PROFESSOR", `Exactly. "${concept.correct}". Good job.`);
                    } else {
                        this.shout("WRONG!");
                        this.shakeScreen();
                        concept.status = 'wrong';
                        await this.showDialogue("PROFESSOR", `Incorrect. I was looking for "${concept.correct}".`);
                    }
                } else { // AI Student's turn
                    this.state = 'DIALOGUE';
                    await this.showDialogue("PROFESSOR", `${concept.topic}: ${concept.q}`);
                    const isRight = Math.random() > 0.4;
                    const answerText = isRight ? concept.correct : concept.wrong;
                    this.state = 'DIALOGUE_STUDENT';
                    await this.showDialogue(student.name.toUpperCase(), answerText);
                    this.state = 'INPUT';
                    const playerJudge = await this.waitForInput();
                    const judgmentCorrect = (isRight && playerJudge) || (!isRight && !playerJudge);

                    if (judgmentCorrect) {
                        this.shout("ACCEPTED!");
                        this.spawnParticles(this.students[2].x, this.students[2].y, '#4ade80');
                        this.addPlayerScore(10);
                        concept.status = 'correct';
                        await this.showDialogue("PROFESSOR", "Well spotted. Correct.");
                    } else {
                        this.shout("OBJECTION!");
                        this.shakeScreen();
                        if (isRight) {
                            student.score += 10;
                            await this.showDialogue("PROFESSOR", `No! ${student.name} was correct.`);
                        } else {
                            await this.showDialogue("PROFESSOR", `Pay attention! That was wrong.`);
                        }
                        concept.status = 'wrong';
                    }
                }
                this.currentRound++;
                setTimeout(() => this.runRound(), 500);
            }

            victory() {
                this.state = 'VICTORY';
                const pScore = this.students[2].score;
                this.shout("CLASS DISMISSED");
                this.showDialogue("PROFESSOR", `Final tally. You scored ${pScore} points. We will review another topic next.`);
                this.advanceCallback = () => this.loadContent(); // Loop to next lesson
            }

            parseJSON(str) {
                if (!str) return null;
                try {
                    const match = str.match(/\[.*\]/s);
                    if (match) return JSON.parse(match[0]);
                    return JSON.parse(str);
                } catch (e) { return null; }
            }

            waitForInput() {
                this.ui.overlay.style.display = 'flex';
                return new Promise(resolve => this.inputResolver = resolve);
            }

            waitForText() {
                this.ui.textOverlay.style.display = 'flex';
                this.ui.inputField.focus();
                return new Promise(resolve => this.textResolver = resolve);
            }

            showDialogue(speaker, text, auto = false) {
                return new Promise(resolve => {
                    this.ui.dialogueBox.style.display = 'block';
                    this.ui.speakerName.innerText = speaker;
                    this.ui.dialogueText.style.color = (speaker === 'PROFESSOR') ? '#000' : '#444'; 
                    if (speaker === 'SYSTEM') this.ui.dialogueText.style.color = '#666';
                    this.ui.dialogueText.innerHTML = ''; 
                    let i = 0;
                    if (this.currentTyping) clearInterval(this.currentTyping);
                    this.currentTyping = setInterval(() => {
                        this.ui.dialogueText.textContent += text.charAt(i);
                        i++;
                        if (i >= text.length) {
                            clearInterval(this.currentTyping);
                            this.currentTyping = null;
                            if (auto) setTimeout(() => resolve(), 1500);
                            else this.advanceCallback = resolve;
                        }
                    }, 30);
                });
            }

            advanceDialogue() {
                if (this.advanceCallback) {
                    const cb = this.advanceCallback;
                    this.advanceCallback = null;
                    cb();
                }
            }

            shout(text) {
                const el = this.ui.shoutBubble;
                el.innerText = text;
                el.style.display = 'block';
                el.classList.add('shake');
                setTimeout(() => {
                    el.style.display = 'none';
                    el.classList.remove('shake');
                }, 1500);
            }

            shakeScreen() {
                this.canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
                setTimeout(() => this.canvas.style.transform = 'none', 100);
            }

            spawnParticles(x, y, color) {
                for(let i=0; i<20; i++) {
                    this.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 60,
                        size: 4,
                        color: color
                    });
                }
            }
        }

        // Resize canvas to fit window with aspect ratio
        const canvas = document.getElementById('game-canvas');
        
        function resize() {
            const aspect = 4/3;
            let w = window.innerWidth;
            let h = window.innerHeight;
            
            // Standard aspect fill
            if (w / h > aspect) { 
                w = h * aspect; 
            } else { 
                // Mobile Portrait or narrow window
                h = w / aspect; 
            }
            
            // Force fit if height is too small (mobile landscape)
            if (h > window.innerHeight) {
                 h = window.innerHeight;
                 w = h * aspect;
            }

            canvas.style.width = `${w}px`;
            canvas.style.height = `${h}px`;
        }
        
        window.addEventListener('resize', resize);
        resize();

        // Start Game
        document.getElementById('btn-start').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            // Audio context requires user interaction
            const engine = new GameEngine(canvas);
            engine.start();
        });
    </script>
</body>
</html>