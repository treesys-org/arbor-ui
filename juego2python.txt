import json
import requests
import re
import sys
import time
import os
import random
from datetime import datetime, timedelta

# =========================================================
#  ARBOR: TUTOR PROTOCOL (LENIENT MODE)
# =========================================================
# Architecture V3.2: "The Navigator"
# - Includes ASCII Map Visualization
# - Tracks Context/Breadcrumbs
# =========================================================

# --- CONFIGURATION ---
OLLAMA_URL = "http://localhost:11434/api/chat"
MODELO = "llama3.1:latest" 

REPO_BASE = "https://raw.githubusercontent.com/treesys-org/arbor-knowledge/main/data"
TARGET_MODULE_PATH = "es/01-computacion/02-sistemas-y-arquitectura/01-sistemas-operativos/01-linux/01-fundamentos-para-principiantes"
GRIMOIRE_FILE = "grimoire.json"

# ---------------------------------------------------------
# UTILS & ROBUSTNESS
# ---------------------------------------------------------

def clean_text_aggressively(raw_html):
    if not raw_html: return ""
    text = re.sub(r'<[^>]+>', ' ', raw_html) 
    text = re.sub(r'http\S+', '', text)
    text = re.sub(r'@\w+:.*', '', text)
    text = re.sub(r'\s+', ' ', text).strip()
    return text

def try_fix_json(bad_json):
    try:
        return json.loads(bad_json)
    except:
        match = re.search(r'\{.*\}', bad_json, re.DOTALL)
        if match:
            try: return json.loads(match.group(0))
            except: pass
    return None

def get_json(url):
    try:
        r = requests.get(url)
        if r.status_code == 200: return r.json()
        return None
    except: return None

def call_ollama(messages, json_mode=False):
    payload = {
        "model": MODELO,
        "messages": messages,
        "stream": False,
        "options": {
            "num_ctx": 4096,
            "temperature": 0.3 
        }
    }
    if json_mode: payload["format"] = "json"

    try:
        r = requests.post(OLLAMA_URL, json=payload)
        r.raise_for_status()
        return r.json()['message']['content']
    except Exception as e:
        print(f"\n[AI Connection Error]: {e}")
        return None

# ---------------------------------------------------------
# MEMORY SYSTEM
# ---------------------------------------------------------
def load_grimoire():
    if os.path.exists(GRIMOIRE_FILE):
        try:
            with open(GRIMOIRE_FILE, 'r') as f: return json.load(f)
        except: return {}
    return {}

def save_grimoire(data):
    with open(GRIMOIRE_FILE, 'w') as f: json.dump(data, f, indent=2)

def update_mastery(lesson_path, won):
    grim = load_grimoire()
    now = datetime.now().isoformat()
    if lesson_path not in grim:
        grim[lesson_path] = { "level": 0, "next_review": now, "history": [] }
    
    entry = grim[lesson_path]
    entry["history"].append("PASS" if won else "FAIL")
    
    if won:
        entry["level"] += 1
        days = 0.5 if entry["level"] == 1 else (entry["level"] * 1.5)
        entry["next_review"] = (datetime.now() + timedelta(days=days)).isoformat()
    else:
        entry["level"] = max(0, entry["level"] - 1)
        entry["next_review"] = now 
        
    save_grimoire(grim)
    return entry["level"]

def pick_encounter(all_levels):
    grim = load_grimoire()
    now = datetime.now().isoformat()
    
    due = [l for l in all_levels if l['contentPath'] in grim and grim[l['contentPath']]['next_review'] <= now]
    if due: return random.choice(due), "REVIEW"

    new = [l for l in all_levels if l['contentPath'] not in grim]
    if new: return new[0], "NEW"
    
    return random.choice(all_levels), "PRACTICE"

# ---------------------------------------------------------
# VISUALIZATION (MAP)
# ---------------------------------------------------------

def print_map(current_level, all_levels):
    """Prints a HUD showing where the user is in the knowledge tree."""
    grim = load_grimoire()
    
    # 1. Print Breadcrumbs (Hierarchy)
    path_str = " > ".join(current_level['path'])
    print("\n" + "="*60)
    print(f"ðŸ—ºï¸  LOCATION: {path_str}")
    print("-" * 60)
    
    # 2. Find siblings (Same parent folder)
    # We filter all_levels to find those that share the same parent path
    parent_path = current_level['path'][:-1] 
    siblings = [l for l in all_levels if l['path'][:-1] == parent_path]
    
    # 3. Print Local Map
    for node in siblings:
        is_current = node['contentPath'] == current_level['contentPath']
        
        # Check status in grimoire
        status = "[ ]" # Not started
        if node['contentPath'] in grim:
            lvl = grim[node['contentPath']]['level']
            if lvl > 0: status = "[âœ“]" # Mastered
            else: status = "[x]" # Failed/Learning
            
        pointer = "ðŸ‘ˆ YOU" if is_current else ""
        
        # Format line
        print(f"  {status} {node['title']} {pointer}")
        
    print("="*60)

# ---------------------------------------------------------
# GAME LOOP
# ---------------------------------------------------------

def download_lesson_content(content_path):
    url = f"{REPO_BASE}/content/{content_path}"
    data = get_json(url)
    if data and 'content' in data:
        return clean_text_aggressively(data['content'])
    return ""

def architect_phase_lenient(level_title, level_text):
    print(f"ðŸ“˜ Preparing lesson: '{level_title}'...")
    
    prompt = f"""
    SYSTEM: You are a Helpful Study Guide Creator.
    INPUT TEXT: "{level_text[:4000]}"
    
    TASK:
    1. Identify the Main Concept.
    2. Create a simple question.
    3. List 3 Keywords.
    
    OUTPUT JSON:
    {{
        "concept": "Short summary",
        "question": "The question",
        "keywords": ["kw1", "kw2", "kw3"],
        "hint": "Clue"
    }}
    """
    resp = call_ollama([{"role": "user", "content": prompt}], json_mode=True)
    data = try_fix_json(resp)
    
    if not data or 'question' not in data:
        return {
            "concept": "General knowledge",
            "question": f"What is the main idea of {level_title}?",
            "keywords": [level_title.split()[-1]],
            "hint": "Define the term."
        }
    return data

def referee_phase_lenient(exam_data, student_answer):
    system_prompt = f"""
    ROLE: Friendly Teacher.
    QUESTION: "{exam_data['question']}"
    KEYWORDS: {exam_data['keywords']}
    ANSWER: "{student_answer}"
    
    TASK: Grade PASS/FAIL based on semantic meaning. Be generous.
    OUTPUT JSON: {{ "grade": "PASS"|"FAIL", "feedback": "Short feedback" }}
    """
    resp = call_ollama([{"role": "user", "content": system_prompt}], json_mode=True)
    data = try_fix_json(resp)
    if not data: return {"grade": "PASS", "feedback": "Good enough!"}
    return data

def main():
    print("\nðŸŽ“ ARBOR: TUTOR MODE")
    
    levels = get_curriculum_map(TARGET_MODULE_PATH) 
    if not levels: 
        print("âŒ Error: Cannot connect to the curriculum.")
        return

    while True:
        # 1. Select Content
        level_meta, enc_type = pick_encounter(levels)
        
        # 2. Show Map
        print_map(level_meta, levels)
        
        # 3. Get Content
        content_text = download_lesson_content(level_meta['contentPath'])
        if not content_text: continue

        # 4. Architect
        exam = architect_phase_lenient(level_meta['title'], content_text)
        
        print(f"\nðŸ“ SUMMARY: {exam['concept']}")
        print(f"â“ QUESTION: {exam['question']}")
        print("-"*60)

        # 5. Loop
        attempts = 0
        while True:
            answer = input("\nAnswer > ")
            if answer.lower() in ['exit', 'quit']: sys.exit()
            if answer.lower() in ['skip']: break
            if answer.lower() in ['hint']: 
                print(f"ðŸ’¡ {exam['hint']}"); continue

            result = referee_phase_lenient(exam, answer)
            print(f"\nðŸ‘¨â€ðŸ« {result['feedback']}")
            
            if result.get('grade') == 'PASS':
                print("\nâœ… GREAT JOB!")
                update_mastery(level_meta['contentPath'], True)
                break
            
            attempts += 1
            if attempts == 1: print(f"\nðŸ’¡ Use words like: {', '.join(exam['keywords'])}")
            if attempts >= 2:
                print(f"\nðŸ¤· Key concept: {exam['concept']}")
                update_mastery(level_meta['contentPath'], False)
                break
        time.sleep(1.0)

# Helper to traverse with Path Tracking
def get_curriculum_map(module_node_path):
    structure_url = f"{REPO_BASE}/nodes/{module_node_path}.json"
    structure = get_json(structure_url)
    levels = []
    
    def traverse(nodes, current_path):
        for node in nodes:
            if node.get('type') == 'branch' and 'apiPath' in node:
                child_data = get_json(f"{REPO_BASE}/nodes/{node['apiPath']}.json")
                if child_data: 
                    # Add current branch name to path and recurse
                    traverse(child_data, current_path + [node['name']])
            elif node.get('type') == 'leaf':
                levels.append({ 
                    "title": node['name'], 
                    "contentPath": node['contentPath'],
                    "path": current_path # Store the hierarchy
                })
                
    if structure: 
        # Start with an empty path or root name
        traverse(structure, [])
    return levels

if __name__ == "__main__":
    main()